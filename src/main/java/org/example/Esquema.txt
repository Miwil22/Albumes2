PARA PROBAR CON POSTMAN

GET http://localhost:3000/api/v1/albumes


POST http://localhost:3000/api/v1/artistas
Content-Type: application/json

{
  "nombre": "Bad Bunny"
}





¬°Claro que s√≠! Vamos a desglosar todo desde cero. Imagina que vamos a construir este proyecto juntos. No te agobies con
 el c√≥digo todav√≠a, primero entiende qu√© estamos construyendo y por qu√©.

Estamos creando una API REST para una tienda de m√∫sica.

API REST: Es como un camarero digital. T√∫ (el cliente) le pides cosas (datos) y √©l te las trae o las lleva a la cocina.

Objetivo: Gestionar √Ålbumes y Artistas. Poder crearlos, leerlos, actualizarlos y borrarlos (CRUD).

0. El Inicio: ¬øQu√© necesito para empezar?
Antes de escribir una sola l√≠nea de c√≥digo, necesitas los cimientos. En Java con Spring Boot, esto se hace en el archivo
 pom.xml.

üì¶ pom.xml (La lista de la compra)
Aqu√≠ le dices a tu proyecto qu√© herramientas (librer√≠as) vas a necesitar.

Spring Web: Para crear el "camarero" (la API).

Spring Data JPA: Para hablar con la base de datos sin saber SQL (la magia).

H2 Database: Una base de datos peque√±ita que vive en la memoria de tu PC (perfecta para aprender y testear).

Lombok: Para no escribir c√≥digo aburrido (Getters, Setters, Constructores) una y otra vez.

Validation: Para asegurar que nadie meta un √°lbum con precio negativo o nombre vac√≠o.

En el examen: Si te preguntan "¬øQu√© dependencia hace falta para validar datos?", la respuesta es spring-boot-starter-validation.

1. El Modelo de Datos (Los Planos)
Lo primero que programamos es: ¬øQu√© datos voy a guardar? En tu proyecto tienes dos "cosas" principales: Album y Artista.

üèõÔ∏è models/Artista.java y models/Album.java
Son clases normales de Java, pero tienen superpoderes gracias a las anotaciones (las palabras que empiezan con @).

@Entity: Le dice a Spring: "Crea una tabla en la base de datos para esta clase".

@Id y @GeneratedValue: "Este campo es la clave primaria y quiero que te inventes t√∫ los n√∫meros (1, 2, 3...)".

La Relaci√≥n (@OneToMany / @ManyToOne):

En Artista: @OneToMany -> Un artista tiene una lista de √°lbumes.

En Album: @ManyToOne -> Muchos √°lbumes pertenecen a un artista.

Esto crea una uni√≥n entre las dos tablas.

2. El Repositorio (El Almac√©n)
Ya tenemos las tablas. Ahora necesitamos alguien que sepa meter y sacar cosas de ah√≠.

üóÑÔ∏è repositories/AlbumRepository.java
Es una Interfaz (una lista de tareas, no de c√≥digo).

extends JpaRepository<Album, Long>: Esta es la magia pura. Solo con escribir esto, Spring te regala m√©todos como:

save() (Guardar)

findAll() (Dame todo)

findById() (Busca por ID)

delete() (Borrar)

Consultas personalizadas: Si los m√©todos regalados no te sirven, creas los tuyos.

Ejemplo: findByNombreContainingIgnoreCase(String nombre) -> Spring traduce esto autom√°ticamente a SQL: SELECT * FROM
albumes WHERE UPPER(nombre) LIKE UPPER('%lo_que_buscas%').

3. Los DTOs y Mappers (La Seguridad y Traducci√≥n)
Regla de oro: NUNCA dejes que el mundo exterior toque tu base de datos directamente. Para eso usamos intermediarios.

üì¶ dto/ (Data Transfer Object)
Son cajas vac√≠as para transportar datos.

AlbumCreateDto: Solo tiene los datos necesarios para crear (nombre, precio, nombre del artista). No tiene ID ni fecha
de creaci√≥n, porque eso lo pone el sistema. Aqu√≠ ponemos las reglas: @NotBlank (no vac√≠o), @Positive (precio positivo).

AlbumResponseDto: Es lo que le ense√±amos al usuario. Aqu√≠ s√≠ va el ID y todo lo bonito.

üîÑ mappers/AlbumMapper.java
Es el traductor.

toAlbum(...): Coge el DTO que env√≠a el usuario y lo convierte en una Entidad lista para guardarse en base de datos.

toAlbumResponseDto(...): Coge la Entidad de la base de datos y la convierte en un DTO bonito para envi√°rselo al usuario.

4. El Servicio (El Cerebro üß†)
Aqu√≠ es donde ocurre la l√≥gica de negocio. El repositorio solo obedece √≥rdenes, el servicio toma decisiones.

‚öôÔ∏è services/AlbumServiceImpl.java
Vamos m√©todo por m√©todo:

findAll(nombre, artista):

¬øMe han dado nombre y artista? -> Busco por los dos.

¬øSolo nombre? -> Busco por nombre.

¬øNada? -> Devuelvo todos.

Aqu√≠ es donde decides qu√© b√∫squeda usar del repositorio.

findById(id):

Llama al repositorio.

¬øNo existe? -> Lanza una Excepci√≥n (AlbumNotFoundException). ¬°Importante! El servicio decide cu√°ndo hay un error.

save(createDto) (Crear):

Paso cr√≠tico: El DTO trae el nombre del artista (ej: "Bad Bunny"). El servicio llama a ArtistaService para buscar a ese
 artista en la base de datos real.

Si el artista no existe, explota (porque as√≠ lo programamos en ArtistaService).

Si existe, crea el √°lbum, le asigna ese artista y lo guarda.

deleteById(id):

Primero comprueba si existe (findById). Si no, error.

Luego lo borra.

La Cach√© (@Cacheable, @CacheEvict): Sirve para que si pides el √°lbum ID 1 cinco veces, la primera va a la base de datos
y las otras 4 te las da de memoria (m√°s r√°pido).

5. El Controlador (La Cara al P√∫blico)
Es quien recibe las peticiones de internet (HTTP).

üåê controllers/AlbumRestController.java
@RestController: Dice "Soy una API web".

@RequestMapping: Define la direcci√≥n base (api/v1/albumes).

M√©todos principales:

getAll (@GetMapping): Recibe par√°metros de la URL (?nombre=...) y llama al servicio.

create (@PostMapping): Recibe el JSON (@RequestBody), comprueba si cumple las reglas del DTO (@Valid) y llama al servicio
 save.

Si @Valid falla (ej: precio negativo), Spring lanza un error autom√°ticamente.

handleValidationExceptions: Es un m√©todo especial al final. Si @Valid falla, este m√©todo captura el error y devuelve un
 mensaje bonito diciendo exactamente qu√© campo fall√≥ ("El precio no puede ser negativo").

6. Los Tests (El Examen antes del Examen)
Los tests aseguran que tu c√≥digo hace lo que dices que hace.

AlbumRepositoryTest: Arranca una base de datos de mentira, guarda un √°lbum y comprueba si findAll lo encuentra. (Prueba
la conexi√≥n a BD).

AlbumServiceImplTest: Aqu√≠ usamos Mocks (simulacros). No usamos la base de datos real. Le decimos al c√≥digo: "Simula que
 el repositorio devuelve este √°lbum cuando te pida el ID 1". Probamos la l√≥gica (los if, las excepciones).

AlbumRestControllerTest: Simula una petici√≥n HTTP real (como si usaras Postman) y comprueba que la API responde con el
c√≥digo correcto (200 OK, 404 Not Found, etc.).

Resumen del Flujo (El camino del dato)
Imagina que quieres crear un √°lbum:

Cliente (Postman): Env√≠a un JSON a POST /api/v1/albumes.

Controlador (AlbumRestController): Recibe el JSON. Verifica @Valid. Si est√° bien, se lo pasa al Servicio.

Servicio (AlbumServiceImpl):

Recibe los datos.

Llama a ArtistaService para ver si el artista existe.

Usa AlbumMapper para convertir los datos en una entidad Album conectada con el Artista.

Llama al repositorio.

Repositorio (AlbumRepository): Genera el SQL (INSERT INTO...) y guarda en H2.

De vuelta: El repositorio devuelve el √°lbum guardado -> Servicio lo convierte a DTO -> Controlador lo env√≠a como JSON
al cliente con un c√≥digo 201 Created.